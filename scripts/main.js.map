{"version":3,"sources":["main.js"],"names":["Providers","resultsList","document","getElementById","resultItems","loadingMessage","querySelector","noResultsMessage","hideResult","result","hidden","removeAttribute","checkIfHideAll","remainingResults","Array","from","filter","length","init","async","fetch","then","response","json","data","JSON","parse","d","fetchData","forEach","provider","ProviderID","DepartmentID","ProviderName","DepartmentName","WaitTime","waitTime","range","min","max","getWaitTime","parseInt","appendChild","createRange","createContextualFragment","remove","setAttribute","querySelectorAll","currentValue","dataset","populated","textContent","toUpperCase","indexOf","onanimationend","showResult","createElement"],"mappings":"AAAA,aAAA,MAAAA,UAAA,WAEA,MAAAC,EAAAC,SAAAC,eAAA,oBAGA,IAAAC,EAEA,MAAAC,EAAAH,SAAAI,cAAA,oBAEAC,EAAAL,SAAAI,cAAA,uBA8HA,SAAAE,EAAAC,GACAA,EAAAC,QAAA,EACAD,EAAAE,gBAAA,mBACAC,IAUA,SAAAA,IAEA,MAAAC,EAAAC,MAAAC,KAAAX,GAAAY,QAAAP,IACA,IAAAA,EAAAC,SAKAH,EAAAG,OAAAG,EAAAI,OAAA,EAGA,MAAA,CACAC,KArJAC,uBAWAA,iBACA,aAAAC,MAAA,oIACAC,MAAAC,GAAAA,EAAAC,SACAF,MAAAG,GACAC,KAAAC,MAAAF,EAAAG,KAbAC,GAAAP,MAAAG,IAEAA,EAmBAK,SAAAC,IAEA,MAAAC,WAAAA,EAAAC,aAAAA,EAAAC,aAAAA,EAAAC,eAAAA,EAAAC,SAAAA,GAAAL,EAGArB,EAAA,2DACAsB,0BAAAC,iIAIAC,MAAAC,2DA8BA,SAAAE,GACA,IAAA3B,EAwBA,MArBA,CACA,CAAA,EAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,KAGAoB,SAAAQ,IAEA,MAAAC,EAAAC,GAAAF,EAGAD,GAAAE,GAAAF,GAAAG,EAEA9B,EAAA,cAAA6B,KAAAC,YACAH,EAAAG,IAEA9B,EAAA,wIAIAA,EAtDA+B,CAAAC,SAAAN,+NAYAlC,EAAAyC,YAAAxC,SAAAyC,cAAAC,yBAAAnC,IAGAJ,EAAAwC,YAIA5C,EAAA6C,aAAA,kBAAA,GAGA1C,EAAAF,SAAA6C,iBAAA,wBA8FA/B,OAzDA,SAAAgC,GAEA/C,EAAAgD,QAAAC,WAEA9C,EAAAyB,SAAApB,IAEAA,EAAAH,cAAA,0BAAA6C,YAGAC,cAAAC,QAAAL,EAAAI,gBAAA,EA4BA,SAAA3C,GACAA,EAAA6C,eAAA,KACA7C,EAAAE,gBAAA,mBACAF,EAAAC,QAAA,EACAE,IA9BA2C,CAAA9C,GAGA,mBAAAP,SAAAsD,cAAA,QAEA/C,EAAAqC,aAAA,kBAAA,UAGArC,EAAA6C,eAAA,KACA9C,EAAAC,KAKAD,EAAAC,QAjIA,GAqKAT,UAAAkB","file":"main.js","sourcesContent":["const Providers = (function() {\n  // Get results unordered list.\n  const resultsList = document.getElementById(\"provider-results\");\n  // Initialize result list items (to be set after results are populated from\n  // API).\n  let resultItems;\n  // Get loading message.\n  const loadingMessage = document.querySelector(\".loading-message\");\n  // Get \"no results\" message.\n  const noResultsMessage = document.querySelector(\".no-results-message\");\n\n  async function init() {\n    // Get provider data.\n    await fetchData().then((data) => {\n      // Populate based on the returned data.\n      populate(data);\n    });\n  }\n\n  /**\n   * Fetches provider data.\n   */\n  async function fetchData() {\n    return await fetch(\"https://tch-bus-dev-waittimes-aps-01.tch-bus-dev-ase-01.p.azurewebsites.net/PublicServices/GetWaitTimes.svc/AllProviderWaitTimes\")\n      .then(response => response.json())\n      .then(data => {\n        return JSON.parse(data.d);\n      });\n  }\n\n  /**\n   * Populates empty unordered list with list items containing provider data.\n   */\n  function populate(providers) {\n    providers.forEach((provider) => {\n      // Destructure provider properties.\n      const { ProviderID, DepartmentID, ProviderName, DepartmentName, WaitTime } = provider;\n\n      // Create list item to populate.\n      const result = `\n        <li class=\"provider-result\" data-provider-id=\"${ProviderID}\" data-department-id=\"${DepartmentID}\">\n          <div class=\"boxed-width\">\n            <div>\n              <p class=\"provider-result__name\">\n                ${ProviderName} (${DepartmentName}):\n                <br><span style=\"font-weight: 400\">${getWaitTime(parseInt(WaitTime))}</span>\n              </p>\n            </div>\n\n            <div class=\"provider-result__icon\">\n              <img src=\"images/icons/check.svg\" alt=\"\"> \n            </div>\n          </div>\n        </li>\n      `;\n\n      // Convert result string to fragment and append to results ul.\n      resultsList.appendChild(document.createRange().createContextualFragment(result));\n\n      // Remove loading message.\n      loadingMessage.remove();\n    });\n\n    // Add hook indicating data has been successfully populated.\n    resultsList.setAttribute(\"data-populated\", true);\n\n    // Get populated items.\n    resultItems = document.querySelectorAll(\".provider-result\");\n  }\n\n  /**\n   * Returns a message with the time range that the actual wait time from the\n   * API fits within.\n   */\n  function getWaitTime(waitTime) {\n    let result;\n\n    // Define ranges.\n    const ranges = [\n      [0, 15],\n      [16, 30],\n      [31, 45],\n      [46, 60],\n    ];\n\n    ranges.forEach((range) => {\n      // Destructure each range array for easier access to the values.\n      const [min, max] = range;\n\n      // Check if given wait time is between current minimum and maximum range.\n      if(waitTime >= min && waitTime <= max) {\n        // Return the range.\n        result = `Wait Time: ${min}â€“${max} Minutes`;\n      } else if(waitTime > max) {\n        // Return modified message if the wait time exceeds all maximums.\n        result = \"Your wait time is currently unavailable. Please visit the front desk if you are interested in learning more about your wait time.\";\n      }\n    });\n\n    return result;\n  }\n  \n  // If the inner text of the result li matches the search term value (case\n  // insensitive), unhide the result. Otherwise, hide it.\n  function filter(currentValue) {\n    // Exit if no data has been populated.\n    if(!resultsList.dataset.populated) return;\n\n    resultItems.forEach((result) => {\n      // Get result.\n      const resultName = result.querySelector(\".provider-result__name\").textContent;\n\n      // If result matches the current search term...\n      if(resultName.toUpperCase().indexOf(currentValue.toUpperCase()) > -1) {\n        // Show it.\n        showResult(result);\n      } else {\n        // Otherwise, hide it.\n        if(\"onanimationend\" in document.createElement(\"div\")) {\n          // Add a hook for attaching a CSS animation.\n          result.setAttribute(\"data-transition\", \"hiding\");\n\n          // Wait until after that animation finishes to hide it.\n          result.onanimationend = () => {\n            hideResult(result);\n          };\n        } else {\n          // If \"onanimationend\" is not supported, just hide without an\n          // animation.\n          hideResult(result);\n        }\n      }\n    });\n  }\n\n  function hideResult(result) {\n    result.hidden = true;\n    result.removeAttribute(\"data-transition\");\n    checkIfHideAll();\n  }\n\n  function showResult(result) {\n    result.onanimationend = null;\n    result.removeAttribute(\"data-transition\");\n    result.hidden = false;\n    checkIfHideAll();\n  }\n\n  function checkIfHideAll() {\n    // Create an array out of provider results that are not hidden.\n    const remainingResults = Array.from(resultItems).filter((result) => {\n      return result.hidden === false;\n    });\n\n    // Show or hide the \"no results\" message depending on whether that array is\n    // empty or populated, respectively.\n    noResultsMessage.hidden = (remainingResults.length > 0);\n  }\n\n  return {\n    init: init,\n    filter: filter,\n  };\n}());\n\nProviders.init();"]}