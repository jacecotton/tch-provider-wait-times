{"version":3,"sources":["main.js"],"names":["Providers","resultsList","document","getElementById","resultItems","loadingMessage","querySelector","noResultsMessage","hideResult","result","hidden","removeAttribute","checkIfHideAll","remainingResults","Array","from","filter","length","init","async","fetch","then","response","json","data","JSON","parse","d","forEach","provider","ProviderID","DepartmentID","ProviderName","DepartmentName","WaitTime","waitTime","range","min","max","getWaitTime","parseInt","appendChild","createRange","createContextualFragment","remove","setAttribute","querySelectorAll","currentValue","dataset","populated","textContent","toUpperCase","indexOf","onanimationend","showResult","createElement"],"mappings":"AAAA,aAAA,MAAAA,UAAA,WAEA,MAAAC,EAAAC,SAAAC,eAAA,oBAGA,IAAAC,EAEA,MAAAC,EAAAH,SAAAI,cAAA,oBAEAC,EAAAL,SAAAI,cAAA,uBAoHA,SAAAE,EAAAC,GACAA,EAAAC,QAAA,EACAD,EAAAE,gBAAA,mBACAC,IAUA,SAAAA,IAEA,MAAAC,EAAAC,MAAAC,KAAAX,GAAAY,QAAAP,IACA,IAAAA,EAAAC,SAKAH,EAAAG,OAAAG,EAAAI,OAAA,EAGA,MAAA,CACAC,KA3IAC,uBAEAC,MAAA,oIAEAC,MAAAC,GAAAA,EAAAC,SAEAF,MAAAG,IAAAC,KAAAC,MAAAF,EAAAG,GAOAC,SAAAC,IAEA,MAAAC,WAAAA,EAAAC,aAAAA,EAAAC,aAAAA,EAAAC,eAAAA,EAAAC,SAAAA,GAAAL,EAGApB,EAAA,2DACAqB,0BAAAC,iIAIAC,MAAAC,2DA8BA,SAAAE,GACA,IAAA1B,EAwBA,MArBA,CACA,CAAA,EAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,KAGAmB,SAAAQ,IAEA,MAAAC,EAAAC,GAAAF,EAGAD,GAAAE,GAAAF,GAAAG,EAEA7B,EAAA,cAAA4B,KAAAC,YACAH,EAAAG,IAEA7B,EAAA,wIAIAA,EAtDA8B,CAAAC,SAAAN,+NAYAjC,EAAAwC,YAAAvC,SAAAwC,cAAAC,yBAAAlC,IAGAJ,EAAAuC,YAIA3C,EAAA4C,aAAA,kBAAA,QAGAzC,EAAAF,SAAA4C,iBAAA,yBA8FA9B,OAzDA,SAAA+B,GAEA9C,EAAA+C,QAAAC,WAEA7C,EAAAwB,SAAAnB,IAEAA,EAAAH,cAAA,0BAAA4C,YAGAC,cAAAC,QAAAL,EAAAI,gBAAA,EA4BA,SAAA1C,GACAA,EAAA4C,eAAA,KACA5C,EAAAE,gBAAA,mBACAF,EAAAC,QAAA,EACAE,IA9BA0C,CAAA7C,GAGA,mBAAAP,SAAAqD,cAAA,QAEA9C,EAAAoC,aAAA,kBAAA,UAGApC,EAAA4C,eAAA,KACA7C,EAAAC,KAKAD,EAAAC,QAvHA,GA2JAT,UAAAkB","file":"main.js","sourcesContent":["const Providers = (function() {\n  // Get results unordered list.\n  const resultsList = document.getElementById(\"provider-results\");\n  // Initialize result list items (to be set after results are populated from\n  // API).\n  let resultItems;\n  // Get loading message.\n  const loadingMessage = document.querySelector(\".loading-message\");\n  // Get \"no results\" message.\n  const noResultsMessage = document.querySelector(\".no-results-message\");\n\n  async function init() {\n    // Get provider data.\n    await fetch(\"https://tch-bus-dev-waittimes-aps-01.tch-bus-dev-ase-01.p.azurewebsites.net/PublicServices/GetWaitTimes.svc/AllProviderWaitTimes\")\n      // Get JSON from result.\n      .then(response => response.json())\n      // Parse JSON and populate providers from data.\n      .then(data => populate(JSON.parse(data.d)));\n  }\n\n  /**\n   * Populates empty unordered list with list items containing provider data.\n   */\n  function populate(providers) {\n    providers.forEach((provider) => {\n      // Destructure provider properties.\n      const { ProviderID, DepartmentID, ProviderName, DepartmentName, WaitTime } = provider;\n\n      // Create list item to populate.\n      const result = `\n        <li class=\"provider-result\" data-provider-id=\"${ProviderID}\" data-department-id=\"${DepartmentID}\">\n          <div class=\"boxed-width\">\n            <div>\n              <p class=\"provider-result__name\">\n                ${ProviderName} (${DepartmentName}):\n                <br><span style=\"font-weight: 400\">${getWaitTime(parseInt(WaitTime))}</span>\n              </p>\n            </div>\n\n            <div class=\"provider-result__icon\">\n              <img src=\"images/icons/check.svg\" alt=\"\"> \n            </div>\n          </div>\n        </li>\n      `;\n\n      // Convert result string to fragment and append to results ul.\n      resultsList.appendChild(document.createRange().createContextualFragment(result));\n\n      // Remove loading message.\n      loadingMessage.remove();\n    });\n\n    // Add hook indicating data has been successfully populated.\n    resultsList.setAttribute(\"data-populated\", true);\n\n    // Get populated items.\n    resultItems = document.querySelectorAll(\".provider-result\");\n  }\n\n  /**\n   * Returns a message with the time range that the actual wait time from the\n   * API fits within.\n   */\n  function getWaitTime(waitTime) {\n    let result;\n\n    // Define ranges.\n    const ranges = [\n      [0, 15],\n      [16, 30],\n      [31, 45],\n      [46, 60],\n    ];\n\n    ranges.forEach((range) => {\n      // Destructure each range array for easier access to the values.\n      const [min, max] = range;\n\n      // Check if given wait time is between current minimum and maximum range.\n      if(waitTime >= min && waitTime <= max) {\n        // Return the range.\n        result = `Wait Time: ${min}â€“${max} Minutes`;\n      } else if(waitTime > max) {\n        // Return modified message if the wait time exceeds all maximums.\n        result = \"Your wait time is currently unavailable. Please visit the front desk if you are interested in learning more about your wait time.\";\n      }\n    });\n\n    return result;\n  }\n  \n  // If the inner text of the result li matches the search term value (case\n  // insensitive), unhide the result. Otherwise, hide it.\n  function filter(currentValue) {\n    // Exit if no data has been populated.\n    if(!resultsList.dataset.populated) return;\n\n    resultItems.forEach((result) => {\n      // Get result.\n      const resultName = result.querySelector(\".provider-result__name\").textContent;\n\n      // If result matches the current search term...\n      if(resultName.toUpperCase().indexOf(currentValue.toUpperCase()) > -1) {\n        // Show it.\n        showResult(result);\n      } else {\n        // Otherwise, hide it.\n        if(\"onanimationend\" in document.createElement(\"div\")) {\n          // Add a hook for attaching a CSS animation.\n          result.setAttribute(\"data-transition\", \"hiding\");\n\n          // Wait until after that animation finishes to hide it.\n          result.onanimationend = () => {\n            hideResult(result);\n          };\n        } else {\n          // If \"onanimationend\" is not supported, just hide without an\n          // animation.\n          hideResult(result);\n        }\n      }\n    });\n  }\n\n  function hideResult(result) {\n    result.hidden = true;\n    result.removeAttribute(\"data-transition\");\n    checkIfHideAll();\n  }\n\n  function showResult(result) {\n    result.onanimationend = null;\n    result.removeAttribute(\"data-transition\");\n    result.hidden = false;\n    checkIfHideAll();\n  }\n\n  function checkIfHideAll() {\n    // Create an array out of provider results that are not hidden.\n    const remainingResults = Array.from(resultItems).filter((result) => {\n      return result.hidden === false;\n    });\n\n    // Show or hide the \"no results\" message depending on whether that array is\n    // empty or populated, respectively.\n    noResultsMessage.hidden = (remainingResults.length > 0);\n  }\n\n  return {\n    init: init,\n    filter: filter,\n  };\n}());\n\nProviders.init();"]}