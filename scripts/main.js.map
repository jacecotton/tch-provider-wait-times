{"version":3,"sources":["main.js"],"names":["Providers","resultsList","document","getElementById","resultItems","loadingMessage","querySelector","noResultsMessage","hideResult","result","hidden","removeAttribute","checkIfHideAll","remainingResults","Array","from","filter","length","fetch","then","response","json","data","JSON","parse","d","forEach","provider","ProviderID","DepartmentID","ProviderName","DepartmentName","WaitTime","waitTime","range","min","max","getWaitTime","parseInt","appendChild","createRange","createContextualFragment","setAttribute","querySelectorAll","remove","currentValue","dataset","populated","textContent","toUpperCase","indexOf","onanimationend","showResult","createElement"],"mappings":"AAAA,aAAA,MAAAA,UAAA,WAEA,MAAAC,EAAAC,SAAAC,eAAA,oBAGA,IAAAC,EAEA,MAAAC,EAAAH,SAAAI,cAAA,oBAEAC,EAAAL,SAAAI,cAAA,uBAsHA,SAAAE,EAAAC,GACAA,EAAAC,QAAA,EACAD,EAAAE,gBAAA,mBACAC,IAUA,SAAAA,IAEA,MAAAC,EAAAC,MAAAC,KAAAX,GAAAY,QAAAP,IACA,IAAAA,EAAAC,SAKAH,EAAAG,OAAAG,EAAAI,OAAA,EAGA,MA5IA,iBAEAC,MAAA,qGAEAC,MAAAC,GAAAA,EAAAC,SACAF,MAAAG,IAEAC,KAAAC,MAAAF,EAAAG,GAWAC,SAAAC,IAEA,MAAAC,WAAAA,EAAAC,aAAAA,EAAAC,aAAAA,EAAAC,eAAAA,EAAAC,SAAAA,GAAAL,EAGAlB,EAAA,2DACAmB,0BAAAC,0JAIAC,MAAAC,2DA2BA,SAAAE,GACA,IAAAxB,EAwBA,MArBA,CACA,CAAA,EAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,IACA,CAAA,GAAA,KAGAiB,SAAAQ,IAEA,MAAAC,EAAAC,GAAAF,EAGAD,GAAAE,GAAAF,GAAAG,EAEA3B,EAAA,cAAA0B,KAAAC,YACAH,EAAAG,IAEA3B,EAAA,wIAIAA,EAnDA4B,CAAAC,SAAAN,+NAYA/B,EAAAsC,YAAArC,SAAAsC,cAAAC,yBAAAhC,OAIAR,EAAAyC,aAAA,kBAAA,GAGAtC,EAAAF,SAAAyC,iBAAA,oBAtCAtC,EAAAuC,aAVA,GA4IA,CACA5B,OAxDA,SAAA6B,GAEA5C,EAAA6C,QAAAC,WAEA3C,EAAAsB,SAAAjB,IAEAA,EAAAH,cAAA,8BAAA0C,YAGAC,cAAAC,QAAAL,EAAAI,gBAAA,EA4BA,SAAAxC,GACAA,EAAA0C,eAAA,KACA1C,EAAAE,gBAAA,mBACAF,EAAAC,QAAA,EACAE,IA9BAwC,CAAA3C,GAGA,mBAAAP,SAAAmD,cAAA,QAEA5C,EAAAiC,aAAA,kBAAA,UAGAjC,EAAA0C,eAAA,KACA3C,EAAAC,KAKAD,EAAAC,QAzHA","file":"main.js","sourcesContent":["const Providers = (function() {\n  // Get results unordered list.\n  const resultsList = document.getElementById(\"provider-results\");\n  // Initialize result list items with outer scope (to be set after results are\n  // populated from API).\n  let resultItems;\n  // Get loading message.\n  const loadingMessage = document.querySelector(\".loading-message\");\n  // Get \"no results\" message.\n  const noResultsMessage = document.querySelector(\".no-results-message\");\n\n  (async () => {\n    // Get provider data.\n    await fetch(\"https://tchcustomservices.texaschildrens.org/PublicServices/GetWaitTimes.svc/AllProviderWaitTimes\")\n      // Get JSON from result.\n      .then(response => response.json())\n      .then((data) => {\n        // Parse JSON and populate providers from data.\n        populate(JSON.parse(data.d));\n\n        // Remove loading message.\n        loadingMessage.remove();\n      });\n  })();\n\n  /**\n   * Populates empty unordered list with list items containing provider data.\n   */\n  function populate(providers) {\n    providers.forEach((provider) => {\n      // Destructure provider properties.\n      const { ProviderID, DepartmentID, ProviderName, DepartmentName, WaitTime } = provider;\n\n      // Create list item to populate.\n      const result = `\n        <li class=\"provider-result\" data-provider-id=\"${ProviderID}\" data-department-id=\"${DepartmentID}\">\n          <div class=\"boxed-width\">\n            <div>\n              <p data-bind-filter-results class=\"provider-result__name\">\n                ${ProviderName} (${DepartmentName}):\n                <br><span style=\"font-weight: 400\">${getWaitTime(parseInt(WaitTime))}</span>\n              </p>\n            </div>\n\n            <div class=\"provider-result__icon\">\n              <img src=\"images/icons/check.svg\" alt=\"\"> \n            </div>\n          </div>\n        </li>\n      `;\n\n      // Convert result string to fragment and append to results ul.\n      resultsList.appendChild(document.createRange().createContextualFragment(result));\n    });\n\n    // Add hook indicating data has been successfully populated.\n    resultsList.setAttribute(\"data-populated\", true);\n\n    // Get populated items.\n    resultItems = document.querySelectorAll(\".provider-result\");\n  }\n\n  /**\n   * Returns a message with the time range that the actual wait time from the\n   * API fits within.\n   */\n  function getWaitTime(waitTime) {\n    let result;\n\n    // Define ranges.\n    const ranges = [\n      [0, 15],\n      [16, 30],\n      [31, 45],\n      [46, 60],\n    ];\n\n    ranges.forEach((range) => {\n      // Destructure each range array for easier access to the values.\n      const [min, max] = range;\n\n      // Check if given wait time is between current minimum and maximum range.\n      if(waitTime >= min && waitTime <= max) {\n        // Return the range.\n        result = `Wait Time: ${min}â€“${max} Minutes`;\n      } else if(waitTime > max) {\n        // Return modified message if the wait time exceeds all maximums.\n        result = \"Your wait time is currently unavailable. Please visit the front desk if you are interested in learning more about your wait time.\";\n      }\n    });\n\n    return result;\n  }\n  \n  // If the inner text of the result li matches the search term value (case\n  // insensitive), unhide the result. Otherwise, hide it.\n  function filter(currentValue) {\n    // Exit if no data has been populated.\n    if(!resultsList.dataset.populated) return;\n\n    resultItems.forEach((result) => {\n      // Get result.\n      const resultName = result.querySelector(\"[data-bind-filter-results]\").textContent;\n\n      // If result matches the current search term...\n      if(resultName.toUpperCase().indexOf(currentValue.toUpperCase()) > -1) {\n        // Show it.\n        showResult(result);\n      } else {\n        // Otherwise, hide it.\n        if(\"onanimationend\" in document.createElement(\"div\")) {\n          // Add a hook for attaching a CSS animation.\n          result.setAttribute(\"data-transition\", \"hiding\");\n\n          // Wait until after that animation finishes to hide it.\n          result.onanimationend = () => {\n            hideResult(result);\n          };\n        } else {\n          // If \"onanimationend\" is not supported, just hide without an\n          // animation.\n          hideResult(result);\n        }\n      }\n    });\n  }\n\n  function hideResult(result) {\n    result.hidden = true;\n    result.removeAttribute(\"data-transition\");\n    checkIfHideAll();\n  }\n\n  function showResult(result) {\n    result.onanimationend = null;\n    result.removeAttribute(\"data-transition\");\n    result.hidden = false;\n    checkIfHideAll();\n  }\n\n  function checkIfHideAll() {\n    // Create an array out of provider results that are not hidden.\n    const remainingResults = Array.from(resultItems).filter((result) => {\n      return result.hidden === false;\n    });\n\n    // Show or hide the \"no results\" message depending on whether that array is\n    // empty or populated, respectively.\n    noResultsMessage.hidden = (remainingResults.length > 0);\n  }\n\n  return {\n    filter: filter,\n  };\n}());"]}